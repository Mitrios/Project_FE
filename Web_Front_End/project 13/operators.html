<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>2_Basic Operators</title>
</head>
<script>
//////The terms "unary", "binary", "operand"//////
///1)unary
var x = 1;
x = -x;
alert( x ); // -1, применили унарный минус
///binary
var x = 1, y = 3;
alert( y - x ); // 2, бинарный минус
2)Сложение строк, бинарный +///
var a = "моя" + "строка";
alert( a ); /// моястрока
////второй вариант строки
alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
///третий вариант остальные арифметические операторы приводят число
alert( 2 - '1' ); //// 1
alert( 6 / '2' ); //// 3
///3)Преобразование к числу, унарный плюс +
alert( +1 ); 
alert( +(1 - 2) ); // -1
///бинарный плюс сложит как строки
var apples = "2";
var oranges = "3";
alert( apples + oranges ); // "23", так как бинарный плюс складывает строки
///Поэтому используем унарный плюс, чтобы преобразовать к числу:
var apples = "2";
var oranges = "3";
alert( +apples + +oranges ); // 5, число, оба операнда предварительно преобразованы в числа
//////4)Присваивание
var x = 2 * 2 + 1;
alert( x );
///5)Взятие остатка %
alert( 5 % 2 ); // 1, остаток от деления 5 на 2
alert( 8 % 3 ); // 2, остаток от деления 8 на 3
alert( 6 % 3 ); // 0, остаток от деления 6 на 3
////6) Инкремент/декремент: ++, --
///Инкремент ++ увеличивает на 1:
 var i = 2;
i++;      // более короткая запись для i = i + 1.
alert(i); // 3
///Декремент -- уменьшает на 1:
 var i = 2;
i--;      // более короткая запись для i = i - 1.
alert(i); // 1
/// пример2
var i = 1;
var a = i++; // (*)
alert(a); // 1
//пример3
var i = 0;
i++;
++i;
alert( i ); // 2
///Если хочется тут же использовать результат, то нужна префиксная форма:
 var i = 0;
alert( ++i ); // 1
///Если нужно увеличить, но нужно значение переменной до увеличения – постфиксная форма:
 var i = 0;
alert( i++ ); // 0
/////&&////
The following code shows examples of the && (logical AND) operator:
console.log(true && true); // t && t returns true
console.log(true && false); // t && f returns false
console.log(false && true); // f && t returns false
console.log(false && (3 == 4)); // f && f returns false
console.log("Kyiv" && "Lviv"); // t && t returns Lviv
console.log(false && "Kyiv"); // f && t returns false
console.log("Kyiv" && false); // t && f returns false
///  || ////
The following code shows examples of the || (logical OR) operator:
console.log(true || true); // t || t returns true
console.log(false || true); // f || t returns true
console.log(true || false); // t || f returns true
console.log(false || (3 == 4)); // f || f returns false
console.log("Kyiv" || "Lviv"); // t || t returns Kyiv
console.log(false || "Kyiv"); // f || t returns Kyiv
console.log("Kyiv" || false); // t || f returns Kyiv
</script>
<body>

<table>
<thead>
<tr>
<th>Приоритет</th>
<th>Название</th>
<th>Обозначение</th>
</tr>
</thead>
<tbody>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>15</td>
<td>унарный плюс</td>
<td><code>+</code></td>
</tr>
<tr>
<td>15</td>
<td>унарный минус</td>
<td><code>-</code></td>
</tr>
<tr>
<td>14</td>
<td>умножение</td>
<td><code>*</code></td>
</tr>
<tr>
<td>14</td>
<td>деление</td>
<td><code>/</code></td>
</tr>
<tr>
<td>13</td>
<td>сложение</td>
<td><code>+</code></td>
</tr>
<tr>
<td>13</td>
<td>вычитание</td>
<td><code>-</code></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>3</td>
<td>присваивание</td>
<td><code>=</code></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>

<br />

<h2>2. Операторы сравнения</h2>
<table class="t3">
<caption>Таблица 4. Операторы сравнения</caption>
<tbody><tr>
<th>Оператор/Операция</th>
<th>Описание</th>
<th>Приоритет</th>
</tr>
<tr>
<td><kbd>==</kbd> Равенство</td>
<td>Проверяет две величины на совпадение, допуская преобразование типов. Возвращает <kbd>true</kbd>, если операнды совпадают, и <kbd>false</kbd>, если они различны.</td>
<td>9</td>
</tr>
<tr>
<td><kbd>!=</kbd> Неравенство</td>
<td>Возвращает <kbd>true</kbd>, если операнды не равны</td>
<td>9</td>
</tr>
<tr>
<td><kbd>===</kbd> Идентичность</td>
<td>Проверяет два операнда на «идентичность», руководствуясь строгим определением совпадения. Возвращает <kbd>true</kbd>, если операнды равны без преобразования типов. </td>
<td>9</td>
</tr>
<tr>
<td><kbd>!==</kbd> Неидентичность</td>
<td>Выполняет проверку идентичности. Возвращает <kbd>true</kbd>, если операнды не равны без преобразования типов.</td>
<td>9</td>
</tr>
<tr>
<td><kbd>&gt;</kbd> Больше</td>
<td>Возвращает <kbd>true</kbd>, если первый операнд больше второго, в противном случае возвращает <kbd>false</kbd>.</td>
<td>10</td>
</tr>
<tr>
<td><kbd>&gt;=</kbd> Больше или равно</td>
<td>Возвращает <kbd>true</kbd>, если первый операнд не меньше второго, в противном случае возвращает <kbd>false</kbd>.</td>
<td>10</td>
</tr>
<tr>
<td><kbd>&lt;</kbd> Меньше</td>
<td>Возвращает <kbd>true</kbd>, если первый операнд меньше второго, в противном случае возвращает <kbd>false</kbd>.</td>
<td>10</td>
</tr>
<tr>
<td><kbd>&lt;=</kbd> Меньше или равно</td>
<td>Возвращает <kbd>true</kbd>, если первый операнд не больше второго, в противном случае возвращает <kbd>false</kbd>.</td>
<td>10</td>
</tr>
</tbody></table>

<!--5 == "5"; // вернет true
5 != -5.0; // вернет true
5 === "5"; // вернет false
false === false; // вернет true
1 !== true; // вернет true
1 != true; // вернет false, так как true преобразуется в 1
3 > -3; // вернет true
3 >= "4"; // вернет false-->


<h3>3. Логические операторы</h3>
<table class="t3">
<caption>Таблица 5. Логические операторы</caption>
<tbody><tr>
<th>Оператор/Операция</th>
<th>Описание</th>
<th>Приоритет</th>
</tr>
<tr>
<td><kbd>&amp;&amp;</kbd> Логическое И</td>
<td>Возвращает <kbd>true</kbd>, только если оба операнда истинны. При выполнении операции сначала проверяется значение первого операнда. Если оно имеет значение <kbd>false</kbd>, то значение второго оператора не учитывается и результату выражения присваивается <kbd>false</kbd>.</td>
<td>5</td>
</tr>
<tr>
<td><kbd>||</kbd> Логическое ИЛИ</td>
<td>Возвращает <kbd>true</kbd>, если хотя бы один операнд истинен, т.е. проверяет истинность как минимум одного условия.</td>
<td>4</td>
</tr>
<tr>
<td><kbd>!</kbd> Логическое НЕ</td>
<td>Изменяет значение оператора на обратное - с <kbd>true</kbd> на <kbd>false</kbd> и наоборот.</td>
<td>14</td>
</tr>
</tbody></table>

<!--(2 < 3) && (3===3); // вернет true, так как выражения в обеих скобках дают true
(x < 10 && x > 0); // вернет true, если значение x принадлежит промежутку от 0 до 10
!false; // вернет true-->

<h4>Побитовые операторы</h4>
<table class="t3">
<caption>Таблица 6. Побитовые операторы</caption>
<tbody><tr>
<th>Оператор/Операция</th>
<th>Описание</th>
<th>Приоритет</th>
</tr>
<tr>
<td><kbd>&amp;</kbd> Побитовый И</td>
<td>Если оба бита равны <kbd>1</kbd>, то результирующий бит будет равен <kbd>1</kbd>. В противном случае результат равен <kbd>0</kbd>.</td>
<td>8</td>
</tr>
<tr>
<td><kbd>|</kbd> Побитовый ИЛИ</td>
<td>Если один из операндов содержит в позиции <kbd>1</kbd>, результат тоже  будет содержать <kbd>1</kbd> в этой позиции, в противном случае результат в этой позиции будет равен <kbd>0</kbd>.</td>
<td>6</td>
</tr>
<tr>
<td><kbd>^</kbd> Исключающее ИЛИ</td>
<td>Если одно, и только одно значение содержит <kbd>1</kbd> в какой-либо позиции, то и результат будет содержать <kbd>1</kbd> в этой позиции, в противном случае результат в этой позиции будет равен <kbd>0</kbd>.</td>
<td>7</td>
</tr>
<tr>
<td><kbd>~</kbd> Отрицание</td>
<td>Выполняется операция побитового отрицания над двоичным представлением значения выражения. Любая позиция, содержащая <kbd>1</kbd> в исходном выражении, заменяется на <kbd>0</kbd>. Любая позиция, содержащая <kbd>0</kbd> в исходном выражении, становится равной <kbd>0</kbd>. Положительные числа начинаются с <kbd>0</kbd>, отрицательные - с <kbd>-1</kbd>, поэтому <kbd>~ n == -(n+1)</kbd>.</td>
<td>14</td>
</tr>
<tr>
<td><kbd>&lt;&lt;</kbd> Побитовый сдвиг влево</td>
<td>Оператор сдвигает биты первого операнда влево на число битовых позиций, установленных вторым операндом. Для заполнения позиций справа используются нули. Возвращают результат того же типа, что левый операнд.</td>
<td>11</td>
</tr>
<tr>
<td><kbd>&gt;&gt;</kbd> Побитовый сдвиг вправо</td>
<td>Оператор сдвигает биты первого операнда вправо на число битовых позиций, установленных вторым операндом. Цифры, сдвинутые за пределы диапазона, удаляются. Самый старший бит (32й) не меняется, чтобы сохранить знак результата. Если первый операнд положителен, старшие биты результата заполняются нулями; если первый операнд отрицателен, старшие биты результата заполняются единицами. Сдвиг значения вправо на одну позицию эквивалентен делению на 2 (с отбрасыванием остатка), а сдвиг вправо на две позиции эквивалентен делению на 4 и т. д.</td>
<td>11</td>
</tr>
<tr>
<td><kbd>&gt;&gt;&gt;</kbd> Побитовый сдвиг вправо без учета знака</td>
<td>Оператор сдвигает биты первого операнда вправо на число битовых позиций, установленных вторым операндом. Слева добавляются нули независимо от знака первого операнда. Цифры, сдвинутые за пределы диапазона, удаляются.</td>
<td>11</td>
</tr>
</tbody></table>

<!--var x = 9, y = 5, z = 2, s = -5, result; // 9 эквивалентно 1001, 5 эквивалентно 0101
result = x & y; // вернет 1 (эквивалентно 0001) 
result = x | y; // вернет 13 (эквивалентно 1101) 
result = x ^ y; // вернет 12 (эквивалентно 1100) 
result = ~ y; // вернет -6 (эквивалентно 1100) 
result = x << y; // вернет 288 (эквивалентно 100100000)
result = x >> z; // вернет 2 (эквивалентно 10)  
result = s >>> z; // вернет 1073741822 (эквивалентно 111111111111111111111111111110)-->

<h5>Строковые операторы</h5>
<table class="t3">
<caption>Таблица 7. Строковые операторы</caption>
<tbody><tr>
<th>Оператор/Операция</th>
<th>Описание</th>
<th>Приоритет</th>
</tr>
<tr>
<td><kbd>+</kbd> Конкатенация</td>
<td>Оператор работает слева направо, выполняя объединение строк. Если первый операнд является строкой, последующие операнды будут преобразованы в строки и далее выполнится их объединение.</td>
<td>12</td>
</tr>
<tr>
<td><kbd>+=</kbd> Конкатенация с присваиванием</td>
<td>Выполняется объединение двух строк и результат присваивается переменной.</td>
<td>12</td>
</tr>
<tr>
<td><kbd>&gt;</kbd>, <kbd>&lt;</kbd>, <kbd>&gt;=</kbd>, <kbd>&lt;=</kbd>, <kbd>==</kbd> Сравнение</td>
<td>Строки сравниваются по алфавиту, буквы в верхнем регистре всегда меньше букв в нижнем регистре. Сравнение строк основывается на номерах символов, указанных в стандарте Unicode, где прописные буквы идут раньше, чем строчные. </td>
<td>10</td>
</tr>
</tbody></table>
<pre class="lang:js decode:true ">"1" + "10"; // вернет "110"
"1" + 10; // вернет "110"
2 + 5 + " цветных карандашей"; // вернет "7 цветных карандашей"
"Цветных карандашей " + 2 + 5; // вернет "Цветных карандашей 25"
"1" &gt; "10"; // вернет false
"10" &lt;= 10; // вернет true
"СССР" == "ссср"; // вернет false
x = "micro"; x+= "soft"; // вернет "microsoft"</pre>
<h6>Специальные операторы</h6>
<table class="t3">
<caption>Таблица 8. Специальные операторы</caption>
<tbody><tr>
<th>Оператор/Операция</th>
<th>Описание</th>
<th>Приоритет</th>
</tr>
<tr>
<td><kbd>.</kbd> Обращение к свойству</td>
<td>Осуществляет доступ к свойству объекта.</td>
<td>15</td>
</tr>
<tr>
<td><kbd>,</kbd> Множественное вычисление</td>
<td>Вычисляет несколько независимых выражений, записанных в одну строку.</td>
<td>1</td>
</tr>
<tr>
<td><kbd>[]</kbd> Индексация массива</td>
<td>Осуществляет доступ к элементам массива или свойствам объекта.</td>
<td>15</td>
</tr>
<tr>
<td><kbd>()</kbd> Вызов функции, группировка</td>
<td>Группирует операции или вызывает функцию.</td>
<td>15</td>
</tr>
<tr>
<td><kbd>typeof</kbd> Определение типа данных</td>
<td>Унарный оператор, возвращает тип данных операнда.</td>
<td>14</td>
</tr>
<tr>
<td><kbd>instanceof</kbd> Проверка типа объекта</td>
<td>Оператор проверяет, является ли объект экземпляром определенного класса. Левый операнд должен быть объектом, правый - должен содержать имя класса объектов. Результат будет <kbd>true</kbd>, если объект, указанный слева, представляет собой экземпляр класса, указанного справа, в противном случае - <kbd>false</kbd>.</td>
<td>10</td>
</tr>
<tr>
<td><kbd>in</kbd> Проверка наличия свойства</td>
<td>В качестве левого операнда должна быть строка, а правым - массив или объект. Если левое значение является свойством объекта, вернется результат <kbd>true</kbd>.</td>
<td>10</td>
</tr>
<tr>
<td><kbd>new</kbd> Создание объекта</td>
<td>Оператор создает новый объект с неопределенными свойствами, затем вызывает функцию-конструктор для его инициализации (передачи параметров). Также может применяться для создания массива.</td>
<td>1</td>
</tr>
<tr>
<td><kbd>delete</kbd> Удаление</td>
<td>Оператор позволяет удалять свойство из объекта или элемент из массива. Возвращает <kbd>true</kbd>, если удаление прошло успешно, в противном случае <kbd>false</kbd>. При удалении элемента массива его длина не меняется.</td>
<td>14</td>
</tr>
<tr>
<td><kbd>void</kbd> Определение выражения без возвращаемого значения</td>
<td>Унарный оператор, отбрасывает значение операнда и возвращает <kbd>underfined</kbd>.</td>
<td>14</td>
</tr>
<tr>
<td><kbd>?:</kbd> Операция условного выражения</td>
<td>Тернарный оператор, позволяет организовать простое ветвление. В выражении участвуют три операнда, первый должен быть логическим значением или преобразовываться в него, а второй и третий - любыми значениями. Если первый операнд равен <kbd>true</kbd>, то условное выражение примет значение второго операнда; если <kbd>false</kbd> - то третьего.</td>
<td>3</td>
</tr>
</tbody></table>
<pre class="lang:js decode:true ">document.write("hello world"); // выводит на экран строку hello world

i = 0, j = 1; // сохраняет значения в переменных

function1(10, 5); // вызов функции function1 с параметрами 10 и 5

var year = [2014, 2015]; // создает массив с элементами

typeof {a:1}; // вернет "object"

var d = new Date(); // создаем новый объект с помощью конструктора Date()
d instanceof Date; // вернет true

var mycar = {make: "Honda", model: "Accord", year: 2005}; 
"make" in mycar; // вернет true

var obj = new Object(); // создает пустой объект

var food = ["milk", "bread", "meat", "olive oil", "cheese"];
delete food[3]; // удаляет четвертый элемент из массива food

x &gt; 10 ? x * 2 : x / 2; // возвращает значение x * 2, если x &gt; 10, в противном случае x / 2
</pre>
</body>
</html>